<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Lab 2 - Vectorization

    Parallel Computing

    Mateo de Mayo - Benjam√≠n Ocampo
---

# Lab 1
Recalling to the first laboratory, the maximum perfomance we have got:
 - N = 128  steps = 512 
 - nanoseconds per cell = 221
 - N = 512  steps = 128  
 - nanoseconds per cell = 232
 - N = 2048  steps = 32 
 - nanoseconds per cell = 268
 - N = 4096  steps = 16  
 - nanoseconds per cell = 267
 - N = 8192  steps = 8  
 - nanoseconds per cell = 265
 
 USE A PLOT.

---

# What it remained under the table.
Function *advect* is called twice in order to perform the function *vel_step*. 
Both of them called with u0 and v0 as parameters.
 
```c
void vel_step(unsigned int n, float *u, float *v, float *u0, float *v0,
              float visc, float dt) {
  ...

  SWAP(u0, u);
  SWAP(v0, v);
  advect(n, VERTICAL, u, u0, u0, v0, dt);
  advect(n, HORIZONTAL, v, v0, u0, v0, dt);
  ...

}
```

---

# What it remained under the table.
 
If we get into the definition of advect:
```c
 static void advect(unsigned int n, boundary b, float *d, const float *d0,
                    const float *u0, const float *v0, float dt) {
   int i0, i1, j0, j1;
   float x, y, s0, t0, s1, t1;
 
   float dt0 = dt * n;
   for (unsigned int i = 1; i <= n; i++) {
     for (unsigned int j = 1; j <= n; j++) {
       x = i - dt0 * u0[IX(i, j)];
       y = j - dt0 * v0[IX(i, j)];
       
       ...
 
       // compute i0, i1, j0, j1 by means of x and y.
 
       ...
 
       d[IX(i, j)] = s0 * (t0 * d0[IX(i0, j0)] + t1 * d0[IX(i0, j1)]) +
                     s1 * (t0 * d0[IX(i1, j0)] + t1 * d0[IX(i1, j1)]);
 
```
 
*u0* and *v0* will be used to compute indexes *i0*, *i1*, *j0* and *j1* in order to update the array *d*.
 
*x* an *y* are computed twice!

---

# Before getting covered in mud

In order to take advantage of *red-black* approach and its profits, the **solver.c** file was re-written 

Functions **advect** and **project** were re-written and the two expensive advect calls were
changed to just one function call which updates *u* and *v*.

---

```c
static void project(unsigned int n, float *u, float *v, float *u0, float *v0) {
  unsigned int color_size = (n + 2) * ((n + 2) / 2);
  float *redu = u;
  float *redv = v;
  float *blku = u + color_size;
  float *blkv = v + color_size;
  float *redu0 = u0;
  float *redv0 = v0;
  float *blku0 = u0 + color_size;
  float *blkv0 = v0 + color_size;
  project_rb_step1(n, RED, redu0, redv0, blku, blkv);
  project_rb_step1(n, BLACK, blku0, blkv0, redu, redv);
  set_bnd(n, NONE, v0);
  set_bnd(n, NONE, u0);
  lin_solve(n, NONE, u0, v0, 1, 4);
  project_rb_step2(n, RED, redu, redv, blku0);
  project_rb_step2(n, BLACK, blku, blkv, redu0);
  set_bnd(n, VERTICAL, u);
  set_bnd(n, HORIZONTAL, v);
}
```
```c
static void advect(unsigned int n, boundary b, float *d, const float *d0,
                   const float *u, const float *v, float dt) {
  unsigned int color_size = (n + 2) * ((n + 2) / 2);
  float *redd = d;
  const float *redu = u;
  const float *redv = v;
  float *blkd = d + color_size;
  const float *blku = u + color_size;
  const float *blkv = v + color_size;
  advect_rb(RED, n, redd, d0, redu, redv, dt);
  advect_rb(BLACK, n, blkd, d0, blku, blkv, dt);
  set_bnd(n, b, d);
}
```

---
```c
static void project_rb_step1(unsigned int n, grid_color color,
                             float *restrict sameu0, float *restrict samev0,
                             float *restrict neighu, float *restrict neighv) {
  int shift = color == RED ? 1 : -1;
  unsigned int start = color == RED ? 0 : 1;
  unsigned int width = (n + 2) / 2;
  for (unsigned int i = 1; i <= n; ++i, start = 1 - start) {
    for (unsigned int j = start; j < width - (1 - start); ++j) {
      int index = idx(j, i, width);
      samev0[index] = -0.5f *
                      (neighu[index - start + 1] - neighu[index - start] +
                       neighv[index + width] - neighv[index - width]) /
                      n;
      sameu0[index] = 0;
    }
  }
}
```
```c
static void project_rb_step2(unsigned int n, grid_color color,
                             float *restrict sameu, float *restrict samev,
                             float *restrict neighu0) {
  int shift = color == RED ? 1 : -1;
  unsigned int start = color == RED ? 0 : 1;
  unsigned int width = (n + 2) / 2;
  for (unsigned int i = 1; i <= n; ++i, start = 1 - start) {
    for (unsigned int j = start; j < width - (1 - start); ++j) {
      int index = idx(j, i, width);
      sameu[index] -=
          0.5f * n * (neighu0[index - start + 1] - neighu0[index - start]);
      samev[index] -=
          0.5f * n * (neighu0[index + width] - neighu0[index - width]);
    }
  }
}
```
---
```c
static void advect_rb(grid_color color, unsigned int n, float *samed,
                      const float *d0, const float *sameu, const float *samev,
                      float dt) {

  ... 

  for (unsigned int i = 1; i <= n; i++, shift = -shift, start = 1 - start) {
    for (unsigned int j = start; j < width - (1 - start); j++) {
      int index = idx(j, i, width);
      unsigned int gridi = i;
      unsigned int gridj = 2 * j + shift + start;
      x = gridj - dt0 * sameu[index];
      y = gridi - dt0 * samev[index];

      ...

      unsigned int i0j0 = IX(j0, i0);
      unsigned int isblack = (j0 % 2) ^ (i0 % 2);
      unsigned int isred = !isblack;
      unsigned int iseven = (i0 % 2 == 0);
      unsigned int isodd = !iseven;
      unsigned int fstart = ((isred && iseven) || (isblack && isodd));
      int fshift = isred ? 1 : -1;
      unsigned int i1j1 = i0j0 + width + (1 - fstart);
      unsigned int i0j1 = i0j0 + fshift * width * (n + 2) + (1 - fstart);
      unsigned int i1j0 = i0j0 + fshift * width * (n + 2) + width;
      samed[index] = s0 * (t0 * d0[i0j0] + t1 * d0[i1j0]) +
                     s1 * (t0 * d0[i0j1] + t1 * d0[i1j1]);
    }
  }
}
```

---

```c
static void vel_advect(unsigned int n, float *restrict u, float *restrict v,
                       const float *restrict u0, const float *restrict v0,
                       float dt) {
  unsigned int color_size = (n + 2) * ((n + 2) / 2);
  float *redu = u;
  float *redv = v;
  float *blku = u + color_size;
  float *blkv = v + color_size;
  const float *redu0 = u0;
  const float *redv0 = v0;
  const float *blku0 = u0 + color_size;
  const float *blkv0 = v0 + color_size;
  vel_advect_rb(RED, n, redu, redv, redu0, redv0, u0, v0, dt);
  vel_advect_rb(BLACK, n, blku, blkv, blku0, blkv0, u0, v0, dt);
  set_bnd(n, VERTICAL, u);
  set_bnd(n, HORIZONTAL, v);
}
```
---
```c
static void vel_advect_rb(grid_color color, unsigned int n,
                          float *restrict sameu, float *restrict samev,
                          const float *sameu0, const float *samev0,
                          const float *u0, const float *v0, float dt) {

  ...

  float dt0 = dt * n;
  for (unsigned int i = 1; i <= n; i++, shift = -shift, start = 1 - start) {
    for (unsigned int j = start; j < width - (1 - start); j++) {
      int index = idx(j, i, width);
      unsigned int gridi = i;
      unsigned int gridj = 2 * j + shift + start;
      x = gridj - dt0 * sameu0[index];
      y = gridi - dt0 * samev0[index];

      ...

      unsigned int i0j0 = IX(j0, i0);
      unsigned int isblack = (j0 % 2) ^ (i0 % 2);
      unsigned int isred = !isblack;
      unsigned int iseven = (i0 % 2 == 0);
      unsigned int isodd = !iseven;
      unsigned int fstart = ((isred && iseven) || (isblack && isodd));
      int fshift = isred ? 1 : -1;
      unsigned int i1j1 = i0j0 + width + (1 - fstart);
      unsigned int i0j1 = i0j0 + fshift * width * (n + 2) + (1 - fstart);
      unsigned int i1j0 = i0j0 + fshift * width * (n + 2) + width;

      sameu[index] = s0 * (t0 * u0[i0j0] + t1 * u0[i1j0]) +
                     s1 * (t0 * u0[i0j1] + t1 * u0[i1j1]);
      samev[index] = s0 * (t0 * v0[i0j0] + t1 * v0[i1j0]) +
                     s1 * (t0 * v0[i0j1] + t1 * v0[i1j1]);
    }
  }
}

```
---

<div align="center">
  <h3>rb vs baseline</h3>
</div>

Comparison between the red-black code given at the beggining of the lab and new red-black version 
was called *baseline* on account of our new starting point.

<div align="center">
  <img src="graphs/nspcellgraph__rb __vs__baseline .png" alt="drawing" style="width:550px;"/>
</div>

---
<div align="center">
  <img src="graphs/l1graph__rb __vs__baseline .png" alt="drawing" style="width:430px;"/>

  <img src="graphs/llcgraph__rb __vs__baseline .png" alt="drawing" style="width:430px;"/>
</div>

---
<div align="center">
  <h3>lab1 vs baseline</h3>
</div>

PUT RESULTS

---

# Different Paths: Instrinsics and ISPC

Up to this point we needed to take different paths, one of us worked with *intrinsics* and the other one with
*ispc*.

Both of us tried to take the same approaches in order to compare how much performance we got with different paths.
Before going to the code the profiler told us were to put focus on.

USE PERF REPORT 

---

## linsolve: ISPC

```c
export void lin_solve_rb_step(uniform int color,
                              uniform int n,
                              uniform float a,
                              uniform float c,
                              const uniform float * uniform same0,
                              const uniform float * uniform neigh,
                              uniform float * uniform same) {
  ...

  for (uniform int y = 1; y <= n; y++, shift = -shift, start = 1 - start) {
    for (uniform int x = start; x < width - programCount; x+= programCount) {
      
      varying int index = x + programIndex + y * width;
      same[index] =
          (same0[index] + a * (neigh[index - width] + neigh[index] +
                                neigh[index + shift] + neigh[index + width])) /
          c;
    }
    varying int xx = programIndex + width - programCount;
    if(xx < width - (1 - start)){
      varying int index = xx + y * width;
      same[index] =
          (same0[index] + a * (neigh[index - width] + neigh[index] +
                                neigh[index + shift] + neigh[index + width])) /
          c;
    }
  }
}
```
---
<div align="center">
  <h3>baseline vs ispc/linsolve</h3>
</div>

<div align="center">
  <img src="graphs/nspcellgraph__baseline __vs__linsolve .png" alt="drawing" style="width:550px;"/>
</div>

---
<div align="center">
  <img src="graphs/l1graph__baseline __vs__linsolve .png" alt="drawing" style="width:430px;"/>

  <img src="graphs/llcgraph__baseline __vs__linsolve .png" alt="drawing" style="width:430px;"/>
</div>

---

## linsolve: intrinsics

---

# Conclusions

---

## And Now What?

We use the profiler to see what was the most expensive routine in the program.

PERF IMAGE

---

```c
export void vel_advect_rb( ... ) {
  ...

  uniform float dt0 = dt * n;
  for (uniform int i = 1; i <= n; i++, shift = -shift, start = 1 - start){
    for (varying int j = programIndex + start;
         j < width - (1 - start);
         j += programCount){
      varying int i0, j0, i1, j1;
      varying float x, y, s0, t0, s1, t1;

      varying int index = j + i * width;
      varying int gridi = i;
      varying int gridj = 2 * j + shift + start;
      x = gridj - dt0 * sameu0[index];
      y = gridi - dt0 * samev0[index];

      x = clamp(x, 0.5f, n + 0.5f);
      y = clamp(y, 0.5f, n + 0.5f);

      ...

      sameu[index] = s0 * (t0 * u0[idx(j0, i0, n + 2)]  + 
                           t1 * u0[idx(j0, i1, n + 2)]) +
                     s1 * (t0 * u0[idx(j1, i0, n + 2)]  + 
                           t1 * u0[idx(j1, i1, n + 2)]);
      samev[index] = s0 * (t0 * v0[idx(j0, i0, n + 2)]  + 
                           t1 * v0[idx(j0, i1, n + 2)]) +
                     s1 * (t0 * v0[idx(j1, i0, n + 2)]  + 
                           t1 * v0[idx(j1, i1, n + 2)]);
    }
  }
}

```

```

---


<div align="center">
  <h3> linsolve vs advect</h3>
</div>

<div align="center">
  <img src="graphs/nspcellgraph__linsolve __vs__advect .png" alt="drawing" style="width:550px;"/>
</div>

---
<div align="center">
  <img src="graphs/l1graph__linsolve __vs__advect .png" alt="drawing" style="width:430px;"/>

  <img src="graphs/llcgraph__linsolve __vs__advect .png" alt="drawing" style="width:430px;"/>
</div>


---

## advect: intrinsics

---

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>